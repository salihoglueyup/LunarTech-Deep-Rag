"""
LunarTech AI - LongWriter Orchestrator v2
Manages the production of a 20,000-word handbook using AgentWrite.

What's new in v2:
- Section-specific RAG queries
- Automatic preface and afterword
- Expansion section if word count is insufficient
"""

import os
import sys
from typing import Callable, Optional
from datetime import datetime

sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
import config
from core.agentwrite import create_plan, write_section
from utils.helpers import count_words


def generate_handbook(
    topic: str,
    context: str,
    target_words: int = None,
    model: str = None,
    progress_callback: Optional[Callable] = None,
    rag_query_func: Optional[Callable] = None,
) -> dict:
    """
    Produces a complete handbook.

    Args:
        rag_query_func: Function to make section-specific RAG queries.
                        Signature: rag_query_func(query: str) -> str
    """
    target_words = target_words or config.MAX_HANDBOOK_WORDS
    start_time = datetime.now()

    # â”€â”€ Step 1: Create Plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _notify(progress_callback, 0, 1, "ðŸ“‹ Generating writing plan...", 0)

    plan = create_plan(
        topic=topic, context=context, target_words=target_words, model=model
    )

    total_steps = len(plan) + 1
    _notify(
        progress_callback,
        1,
        total_steps,
        f"âœ… Plan is ready! {len(plan)} chapters planned.",
        0,
    )

    # â”€â”€ Step 2: Write Chapters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    written_sections = []
    section_contents = []
    total_words = 0

    for i, section in enumerate(plan):
        section_num = i + 1
        _notify(
            progress_callback,
            section_num + 1,
            total_steps,
            f"âœï¸ Chapter {section_num}/{len(plan)}: {section.get('title', '')}",
            total_words,
        )

        # Section-specific RAG query
        section_context = None
        rag_query = section.get("rag_query")
        if rag_query and rag_query_func:
            try:
                section_context = rag_query_func(rag_query)
            except Exception:
                section_context = None

        # Write the chapter
        content = write_section(
            topic=topic,
            section=section,
            context=(
                context + f"\n\nMANDATORY INSTRUCTION:\n"
                f"- This section MUST BE AT LEAST {section['target_words']} words.\n"
                f"- Writing a shorter output is a critical failure.\n"
                f"- Use a formal, academic handbook tone.\n"
                f"- Add examples, tables, and counter-arguments."
            ),
            previous_sections=section_contents[-2:],  # critical
            model=model,
            section_context=section_context,
        )

        section_words = count_words(content)

        # Expansion loop has been cancelled, agentwrite handles it iteratively.

        total_words += section_words

        section_contents.append(content)
        written_sections.append(
            {
                "section_number": section_num,
                "title": section.get("title", f"Chapter {section_num}"),
                "content": content,
                "word_count": section_words,
            }
        )

        _notify(
            progress_callback,
            section_num + 1,
            total_steps,
            f"âœ… Chapter {section_num} completed ({section_words} words). Total: {total_words}",
            total_words,
        )

    # â”€â”€ Step 3: Cancelled, Each Chapter Will Grow Internally â”€â”€

    # â”€â”€ Step 4: Assemble â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    handbook_content = _assemble_handbook(topic, written_sections)
    final_word_count = count_words(handbook_content)

    elapsed = datetime.now() - start_time
    elapsed_str = f"{elapsed.seconds // 60} mins {elapsed.seconds % 60} secs"

    _notify(
        progress_callback,
        total_steps,
        total_steps,
        f"ðŸŽ‰ Handbook completed! {final_word_count} words, took {elapsed_str}.",
        final_word_count,
    )

    return {
        "title": f"{topic} - Handbook",
        "content": handbook_content,
        "word_count": final_word_count,
        "section_count": len(written_sections),
        "sections": written_sections,
        "generation_time": elapsed_str,
    }


def _assemble_handbook(topic: str, sections: list[dict]) -> str:
    """Assembles all chapters into a single Markdown document."""
    parts = []

    # Cover page
    parts.append(f"# ðŸ“˜ {topic}")
    parts.append("")
    parts.append(f"> *This handbook has been automatically generated by LunarTech AI.*")
    parts.append(
        f"> *Model: AgentWrite (LongWriter) Â· Date: {datetime.now().strftime('%d %B %Y, %H:%M')}*"
    )
    parts.append("")

    # Table of Contents
    parts.append("## ðŸ“‘ Table of Contents")
    parts.append("")
    for section in sections:
        num = section["section_number"]
        title = section["title"]
        words = section.get("word_count", 0)
        parts.append(f"{num}. [{title}](#{_slug(title)}) *({words:,} words)*")
    parts.append("")

    # Total Word Count
    total = sum(s.get("word_count", 0) for s in sections)
    parts.append(f"**Total: {total:,} words Â· {len(sections)} chapters**")
    parts.append("")
    parts.append("---")
    parts.append("")

    # Chapters
    for i, section in enumerate(sections):
        parts.append(section["content"])
        parts.append("")
        if i < len(sections) - 1:
            parts.append("---")
            parts.append("")

    # Footer
    parts.append("---")
    parts.append("")
    parts.append(f"*Â© {datetime.now().year} LunarTech AI â€” All rights reserved.*")

    return "\n".join(parts)


def _slug(text: str) -> str:
    import re

    slug = text.lower().strip()
    slug = re.sub(r"[^\w\s-]", "", slug)
    slug = re.sub(r"[\s_]+", "-", slug)
    return slug


def _notify(callback, step, total, message, current_words):
    if callback:
        try:
            callback(step, total, message, current_words)
        except Exception:
            pass


# â”€â”€ INTERACTIVE HANDBOOK GENERATION (HUMAN-IN-THE-LOOP) â”€â”€


def init_interactive_handbook(
    topic: str, context: str, target_words: int = None, model: str = None
) -> dict:
    target_words = target_words or config.MAX_HANDBOOK_WORDS
    plan = create_plan(
        topic=topic, context=context, target_words=target_words, model=model
    )
    return {
        "topic": topic,
        "context": context,
        "target_words": target_words,
        "plan": plan,
        "written_sections": [],
        "section_contents": [],
        "total_words": 0,
        "current_idx": 0,
        "model": model,
        "start_time": datetime.now().isoformat(),
    }


def generate_handbook_section(
    state: dict, custom_instruction: str = None, rag_query_func: Callable = None
) -> str:
    idx = state["current_idx"]
    if idx >= len(state["plan"]):
        return None

    section = dict(state["plan"][idx])

    section_context = None
    rag_query = section.get("rag_query")
    if rag_query and rag_query_func:
        try:
            section_context = rag_query_func(rag_query)
        except Exception:
            pass

    if custom_instruction:
        section["description"] = (
            section.get("description", "")
            + f"\n\n[USER REVISION REQUEST]: {custom_instruction}"
        )

    content = write_section(
        topic=state["topic"],
        section=section,
        context=state["context"],
        previous_sections=state["section_contents"],
        model=state["model"],
        section_context=section_context,
    )
    return content


def approve_handbook_section(state: dict, content: str) -> dict:
    idx = state["current_idx"]
    section = state["plan"][idx]

    section_words = count_words(content)
    state["total_words"] += section_words
    state["section_contents"].append(content)
    state["written_sections"].append(
        {
            "section_number": idx + 1,
            "title": section.get("title", f"Chapter {idx+1}"),
            "content": content,
            "word_count": section_words,
        }
    )
    state["current_idx"] += 1
    return state


def finalize_interactive_handbook(state: dict) -> dict:
    handbook_content = _assemble_handbook(state["topic"], state["written_sections"])

    start_time = datetime.fromisoformat(state["start_time"])
    elapsed = datetime.now() - start_time
    elapsed_str = f"{elapsed.seconds // 60} mins {elapsed.seconds % 60} secs"

    return {
        "title": f"{state['topic']} - Handbook",
        "content": handbook_content,
        "word_count": state["total_words"],
        "section_count": len(state["written_sections"]),
        "sections": state["written_sections"],
        "generation_time": elapsed_str,
    }
